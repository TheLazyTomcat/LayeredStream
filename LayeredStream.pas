unit LayeredStream;

{$IFDEF FPC}
  {$MODE ObjFPC}
{$ELSE}
{$ENDIF}
{$H+}

{$message 'add ConnectedBuffer(Writer/Reader)'}

interface

uses
  SysUtils, Classes,
  AuxClasses,
  SimpleNamedValues;

type
  ELSException = class(Exception);

  ELSIndexOutOfBounds    = class(ELSException);
  ELSInvalidConnection   = class(ELSException);
  ELSLayerIntegrityError = class(ELSException);

{===============================================================================
--------------------------------------------------------------------------------
                               TLSLayerObjectBase
--------------------------------------------------------------------------------
===============================================================================}

  TLSLayerObjectType = (lotUndefined,lotReader,lotWriter);

  TLSLayerObjectBehavior = (
  {
    lobPassthrough

    Data are directly passing through and are not changed or delayed in any way.
  }
    lobPassthrough,
  {
    lobObserver

    Data are observed and some processing is done on them (eg. hashing,
    statistics, ...).
    This behavior does not tell whether the data are in any way changed or
    delayed, it merely indicates that some processing is done on them.
  }
    lobObserver,
  {
    lobProcessor

    Data are changed in some way (eg. compressed, encrypted, ...).
  }
    lobProcessor,
  {
    lobSplitter

    At least part of the data, and possibly all of them, is passed to some side
    channel - but they are not removed from the streaming, merely copied.
  }
    lobSplitter,
  {
    lobJoiner

    Some data are added to the streaming from a side channel.
  }
    lobJoiner,
  {
    lobAccumulator

    Data are accumulated in the layer and are not directly streamed. They might
    be streamed at some given point or at the end of processing (finalization).
    Typical case is buffering.
  }
    lobAccumulator,
  {
    lobConsumer

    Data are at least in part consumed by the layer - that is, some or all of
    the data are removed from the streaming.
  }
    lobConsumer,
  {
    lobGenerator

    New data can be generated by the layer and added to the streaming. It is
    even possible that the layer is producing data with no input at all.
  }
    lobGenerator,

  {
    lobOther

    Some unspecified processing that does not fit any of the above options.
  }
    lobOther);

  TLSLayerObjectKind = set of TLSLayerObjectBehavior;

{
  types used to return information about accepted parameters
}
  TLSLayerObjectParamReceiver = (loprConstructor,loprInitializer);

  TLSLayerObjectParamReceivers = set of TLSLayerObjectParamReceiver;

  TLSLayerObjectParam = record
    Name:        String;
    ValueType:   TSNVNamedValueType;
    Receivers:   TLSLayerObjectParamReceivers;
    Description: String;
  end;

  TLSLayerObjectParams = array of TLSLayerObjectParam;

Function LayerObjectParam(const Name: String; ValueType: TSNVNamedValueType; Receivers: TLSLayerObjectParamReceivers; const Description: String): TLSLayerObjectParam;

{
  connection events
}
type
  TLSLayerObjectSeekConnection = Function(const Offset: Int64; Origin: TSeekOrigin): Int64 of object;
  TLSLayerObjectReadConnection = Function(out Buffer; Size: LongInt): LongInt of object;
  TLSLayerObjectWriteConnection = Function(const Buffer; Size: LongInt): LongInt of object;

{===============================================================================
    TLSLayerObjectBase - class declaration
===============================================================================}
type
  TLSLayerObjectBase = class(TCustomObject)
  protected
    fCounterpart:     TLSLayerObjectBase; // the orher object in layer pair
    fSeekConnection:  TLSLayerObjectSeekConnection;
    fActive:          Boolean;
    procedure SetCounterpart(Value: TLSLayerObjectBase); virtual;
    procedure SetActive(Value: Boolean); virtual;
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual; abstract;
    Function SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    procedure Initialize(Params: TSimpleNamedValues); virtual;
    procedure Finalize; virtual;
  public
    class Function LayerObjectType: TLSLayerObjectType; virtual;      // reader/writer
    class Function LayerObjectKind: TLSLayerObjectKind; virtual;      // set of behaviors
    class Function LayerObjectParams: TLSLayerObjectParams; virtual;  // list of accepted parameters
    constructor Create(Params: TSimpleNamedValues);
    destructor Destroy; override;
    procedure InternalInit; virtual;  // called by layered stream after the layer is set up, do not call yourself!
    procedure InternalFinal; virtual; // called by layered stream before the layer is removed, calls flush, do not call yourself!
  {
    Note that calling Init or Final is not mandatory, they are here only for
    those layer objects that really do need them.
  }
    procedure Init(Params: TSimpleNamedValues = nil); virtual;  // can be called any time, multiple times
    procedure Final; virtual;                                   // -//-
    procedure Flush; virtual;
    Function SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    property Counterpart: TLSLayerObjectBase read fCounterpart write SetCounterpart;
    property SeekConnection: TLSLayerObjectSeekConnection read fSeekConnection write fSeekConnection;
    property Active: Boolean read fActive write SetActive;
  end;

  TLSLayerObjectClass = class of TLSLayerObjectBase;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLSLayerReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerReader - class declaration
===============================================================================}
type
  TLSLayerReader = class(TLSLayerObjectBase)
  protected
    fReadConnection:  TLSLayerObjectReadConnection;
    Function ReadActive(out Buffer; Size: LongInt): LongInt; virtual; abstract;
    Function ReadOut(out Buffer; Size: LongInt): LongInt; virtual;
  public
    class Function LayerObjectType: TLSLayerObjectType; override;
    Function ReadIn(out Buffer; Size: LongInt): LongInt; virtual;
    property ReadConnection: TLSLayerObjectReadConnection read fReadConnection write fReadConnection;
  end;

  TLSLayerReaderClass = class of TLSLayerReader;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLSLayerWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerWriter - class declaration
===============================================================================}
type
  TLSLayerWriter = class(TLSLayerObjectBase)
  protected
    fWriteConnection: TLSLayerObjectWriteConnection;
    Function WriteActive(const Buffer; Size: LongInt): LongInt; virtual; abstract;
    Function WriteOut(const Buffer; Size: LongInt): LongInt; virtual;
  public
    class Function LayerObjectType: TLSLayerObjectType; override;
    Function WriteIn(const Buffer; Size: LongInt): LongInt; virtual;
    property WriteConnection: TLSLayerObjectWriteConnection read fWriteConnection write fWriteConnection;
  end;

  TLSLayerWriterClass = class of TLSLayerWriter;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLayeredStream
--------------------------------------------------------------------------------
===============================================================================}
type
  TLayeredStreamMode = (lsmUndefined,lsmSeek,lsmRead,lsmWrite);

  TLSLayer = record
    Name:   String;
    Reader: TLSLayerReader;
    Writer: TLSLayerWriter;
  end;

  // for use in constructor...
  TLSLayerConstruct = record
    Name:         String;
    Reader:       TLSLayerReaderClass;
    Writer:       TLSLayerWriterClass;
    ReaderParams: TSimpleNamedValues;
    WriterParams: TSimpleNamedValues;
  end;

Function LayerConstruct(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): TLSLayerConstruct; overload;
Function LayerConstruct(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass): TLSLayerConstruct; overload;

{===============================================================================
    TLayeredStream - class declaration
===============================================================================}

type
  TLayeredStream = class(TStream)
  private
    fMode:        TLayeredStreamMode;
    fTarget:      TStream;
    fOwnsTarget:  Boolean;
    fLayers:      array of TLSLayer;
    Function GetLayerCount: Integer;
    Function GetLayer(Index: Integer): TLSLayer;
    Function GetLayerName(Index: Integer): String;
    procedure SetLayerName(Index: Integer; const Value: String);
    Function GetLayerActive(Index: Integer): Boolean;
    procedure SetLayerActive(Index: Integer; Value: Boolean);
  protected
    Function ChangeMode(NewMode: TLayeredStreamMode): TLayeredStreamMode; virtual;  // returns previous mode
    Function ReadIn(out Buffer; Size: LongInt): LongInt; virtual;
    Function ReadOut(out Buffer; Size: LongInt): LongInt; virtual;
    Function WriteIn(const Buffer; Size: LongInt): LongInt; virtual;
    Function WriteOut(const Buffer; Size: LongInt): LongInt; virtual;
    Function SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    Function SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    procedure FlushReaders; virtual;    // flushed from top to botom
    procedure FlushWriters; virtual;    // -//-
    procedure InitializeLayer(Index: Integer); virtual;
    procedure FinalizeLayer(Index: Integer); virtual;
    procedure ConnectLayer(Index: Integer); virtual;
    procedure DisconnectLayer(Index: Integer); virtual;
    procedure Initialize; virtual;
    procedure Finalize; virtual;
  public
    constructor Create(Target: TStream); overload;
    constructor Create(Target: TStream; Layers: array of TLSLayerConstruct); overload;
    destructor Destroy; override;
    // layers list index
    Function LowIndex: Integer; virtual;
    Function HighIndex: Integer; virtual;
    Function CheckIndex(Index: Integer): Boolean; virtual;
    Function IndexOf(const LayerName: String): Integer; overload; virtual;    // case sensitive!
    Function IndexOf(LayerObjectClass: TLSLayerObjectClass): Integer; overload; virtual;
    Function IndexOf(LayerObject: TLSLayerObjectBase): Integer; overload; virtual;
    Function Find(const LayerName: String; out Index: Integer): Boolean; overload; virtual;
    Function Find(LayerObjectClass: TLSLayerObjectClass; out Index: Integer): Boolean; overload; virtual;
    Function Find(LayerObject: TLSLayerObjectBase; out Index: Integer): Boolean; overload; virtual;
    Function Add(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer; overload; virtual;
    Function Add(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer; overload; virtual;
    Function Add(LayerConstruct: TLSLayerConstruct): Integer; overload; virtual;
    procedure Insert(Index: Integer; const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil); overload; virtual;
    procedure Insert(Index: Integer; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil); overload; virtual;
    procedure Insert(Index: Integer; LayerConstruct: TLSLayerConstruct); overload; virtual;
    Function Remove(const LayerName: String): Integer; overload; virtual;
    Function Remove(LayerObjectClass: TLSLayerObjectClass): Integer; overload; virtual;
    Function Remove(LayerObject: TLSLayerObjectBase): Integer; overload; virtual;  
    procedure Delete(Index: Integer); virtual;
    procedure Clear; virtual;
    // layers methods
    procedure Init; virtual;  // initilizes all layers from first to last
    procedure Final; virtual; // finalizes all layers from last to first
    procedure Flush; virtual; // flushes all layers according to mode (FlushReaders, FlushWriters)
    {$message 'implement'}
    //procedure Init(Index: Integer; ReaderParams, WriterParams: TSimpleNamedValues = nil); overload; virtual;
    //procedure Final(Index: Integer); overload; virtual;
    //procedure Flush(Index: Integer); overload; virtual;
    //procedure InitReader(Index: Integer; Params: TSimpleNamedValues = nil); virtual;
    //procedure InitWriter(Index: Integer; Params: TSimpleNamedValues = nil); virtual;
    //procedure FinalReader(Index: Integer); virtual;
    //procedure FinalWriter(Index: Integer); virtual;
    //procedure FlushReader(Index: Integer);
    //procedure FlushWriter(Index: Integer);
    // stream methods
    Function Seek(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function Read(var Buffer; Count: LongInt): LongInt; override;
    Function Write(const Buffer; Count: LongInt): LongInt; override;
    // properties
    property Mode: TLayeredStreamMode read fMode;
    property Target: TStream read fTarget;
    property OwnsTarget: Boolean read fOwnsTarget write fOwnsTarget;
    property Count: Integer read GetLayerCount;
    property Layers[Index: Integer]: TLSLayer read GetLayer; default;
    property LayerNames[Index: Integer]: String read GetLayerName write SetLayerName;
    property LayerActive[Index: Integer]: Boolean read GetLayerActive write SetLayerActive;
  end;      

implementation

{===============================================================================
--------------------------------------------------------------------------------
                               TLSLayerObjectBase
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerObjectBase - Auxiliary functions
===============================================================================}

Function LayerObjectParam(const Name: String; ValueType: TSNVNamedValueType; Receivers: TLSLayerObjectParamReceivers; const Description: String): TLSLayerObjectParam;
begin
Result.Name := Name;
Result.ValueType := ValueType;
Result.Receivers := Receivers;
Result.Description := Description;
end;

{===============================================================================
    TLSLayerObjectBase - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerObjectBase - protected methods
-------------------------------------------------------------------------------}

procedure TLSLayerObjectBase.SetCounterpart(Value: TLSLayerObjectBase);
begin
fCounterpart := Value;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.SetActive(Value: Boolean);
begin
If Value <> fActive then
  begin
    If not Value then // deactivating, do flush
      Flush;
    fActive := Value;
  end;
end;

//------------------------------------------------------------------------------

Function TLSLayerObjectBase.SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := 0;
If Assigned(fSeekConnection) then
  Result := fSeekConnection(Offset,Origin)
else
  ELSInvalidConnection.Create('TLSLayerObjectBase.SeekOut: Seek connection not assigned.');
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Initialize(Params: TSimpleNamedValues);
begin
fCounterpart := nil;
fSeekConnection := nil;
fActive := True;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Finalize;
begin
// no action
end;

{-------------------------------------------------------------------------------
    TLSLayerObjectBase - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerObjectBase.LayerObjectType: TLSLayerObjectType;
begin
Result := lotUndefined;
end;

//------------------------------------------------------------------------------

class Function TLSLayerObjectBase.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [];
end;

//------------------------------------------------------------------------------

class Function TLSLayerObjectBase.LayerObjectParams: TLSLayerObjectParams;
begin
SetLength(Result,0);
end;

//------------------------------------------------------------------------------

constructor TLSLayerObjectBase.Create(Params: TSimpleNamedValues);
begin
inherited Create;
Initialize(Params);
end;

//------------------------------------------------------------------------------

destructor TLSLayerObjectBase.Destroy;
begin
Finalize;
inherited;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.InternalInit;
begin
// no action
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.InternalFinal;
begin
Flush;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Init(Params: TSimpleNamedValues = nil);
begin
// nothing to do
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Final;
begin
// nothing to do
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Flush;
begin
// nothing to do
end;

//------------------------------------------------------------------------------

Function TLSLayerObjectBase.SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
If fActive then
  Result := SeekActive(Offset,Origin)
else
  Result := SeekOut(Offset,Origin);
end;

{===============================================================================
--------------------------------------------------------------------------------
                              TLSLayerReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerReader - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerReader - protected methods
-------------------------------------------------------------------------------}

Function TLSLayerReader.ReadOut(out Buffer; Size: LongInt): LongInt;
begin
Result := 0;
If Assigned(fReadConnection) then
  Result := fReadConnection(Buffer,Size)
else
  ELSInvalidConnection.Create('TLSLayerReader.ReadOut: Read connection not assigned.');
end;

{-------------------------------------------------------------------------------
    TLSLayerReader - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerReader.LayerObjectType: TLSLayerObjectType;
begin
Result := lotReader;
end;

//------------------------------------------------------------------------------

Function TLSLayerReader.ReadIn(out Buffer; Size: LongInt): LongInt;
begin
If fActive then
  Result := ReadActive(Buffer,Size)
else
  Result := ReadOut(Buffer,Size);
end;

{===============================================================================
--------------------------------------------------------------------------------
                              TLSLayerWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerWriter - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerWriter - protected methods
-------------------------------------------------------------------------------}

Function TLSLayerWriter.WriteOut(const Buffer; Size: LongInt): LongInt;
begin
Result := 0;
If Assigned(fWriteConnection) then
  Result := fWriteConnection(Buffer,Size)
else
  ELSInvalidConnection.Create('TLSLayerWriter.WriteOut: Write connection not assigned.');
end;

{-------------------------------------------------------------------------------
    TLSLayerWriter - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerWriter.LayerObjectType: TLSLayerObjectType;
begin
Result := lotWriter;
end;

//------------------------------------------------------------------------------

Function TLSLayerWriter.WriteIn(const Buffer; Size: LongInt): LongInt;
begin
If fActive then
  Result := WriteActive(Buffer,Size)
else
  Result := WriteOut(Buffer,Size);
end;


{===============================================================================
--------------------------------------------------------------------------------
                                 TLayeredStream
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLayeredStream - Auxiliary functions
===============================================================================}

Function LayerConstruct(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): TLSLayerConstruct;
begin
Result.Name := Name;
Result.Reader := Reader;
Result.Writer := Writer;
Result.ReaderParams := ReaderParams;
Result.WriterParams := WriterParams;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function LayerConstruct(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass): TLSLayerConstruct;
begin
Result := LayerConstruct('',Reader,Writer);
end;

{===============================================================================
    TLayeredStream - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLayeredStream - pritave methods
-------------------------------------------------------------------------------}

Function TLayeredStream.GetLayerCount: Integer;
begin
Result := Length(fLayers);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.GetLayer(Index: Integer): TLSLayer;
begin
If CheckIndex(Index) then
  Result := fLayers[Index]
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.GetLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.GetLayerName(Index: Integer): String;
begin
If CheckIndex(Index) then
  Result := fLayers[Index].Name
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.GetLayerName: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.SetLayerName(Index: Integer; const Value: String);
begin
If CheckIndex(Index) then
  fLayers[Index].Name := Value
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.SetLayerName: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.GetLayerActive(Index: Integer): Boolean;
begin
If CheckIndex(Index) then
  begin
    If fLayers[Index].Reader.Active = fLayers[Index].Writer.Active then
      Result := fLayers[Index].Reader.Active
    else
      raise ELSLayerIntegrityError.CreateFmt('TLayeredStream.GetLayerActive: Layer #%d active setting mismatch.',[Index]);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.GetLayerActive: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.SetLayerActive(Index: Integer; Value: Boolean);
begin
If CheckIndex(Index) then
  begin
    If fLayers[Index].Reader.Active = fLayers[Index].Writer.Active then
      begin
        fLayers[Index].Reader.Active := Value;
        fLayers[Index].Writer.Active := Value;
      end
    else raise ELSLayerIntegrityError.CreateFmt('TLayeredStream.SetLayerActive: Layer #%d active setting mismatch.',[Index]);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.SetLayerActive: Index (%d) out of bounds.',[Index]);
end;

{-------------------------------------------------------------------------------
    TLayeredStream - protected methods
-------------------------------------------------------------------------------}

Function TLayeredStream.ChangeMode(NewMode: TLayeredStreamMode): TLayeredStreamMode;
begin
Result := fMode;
If fMode <> NewMode then
  begin
    Flush;
    fMode := NewMode;
  end;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.ReadIn(out Buffer; Size: LongInt): LongInt;
begin
ChangeMode(lsmRead);
If Length(fLayers) > 0 then
  Result := fLayers[HighIndex].Reader.ReadIn(Buffer,Size)
else
  Result := ReadOut(Buffer,Size);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.ReadOut(out Buffer; Size: LongInt): LongInt;
begin
Result := fTarget.Read(Buffer,Integer(Size));
end;

//------------------------------------------------------------------------------

Function TLayeredStream.WriteIn(const Buffer; Size: LongInt): LongInt;
begin
ChangeMode(lsmWrite);
If Length(fLayers) > 0 then
  Result := fLayers[HighIndex].Writer.WriteIn(Buffer,Size)
else
  Result := WriteOut(Buffer,Size);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.WriteOut(const Buffer; Size: LongInt): LongInt;
begin
Result := fTarget.Write(Buffer,Integer(Size));
end;

//------------------------------------------------------------------------------

Function TLayeredStream.SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64;
var
  OldMode:  TLayeredStreamMode;
begin
OldMode := ChangeMode(lsmSeek);
If Length(fLayers) > 0 then
  begin
    case OldMode of
      lsmRead:  Result := fLayers[HighIndex].Reader.SeekIn(Offset,Origin);
      lsmWrite: Result := fLayers[HighIndex].Writer.SeekIn(Offset,Origin);
    else
     {lsmUndefined,lsmSeek}
      Result := SeekOut(Offset,Origin);
    end;
  end
else Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := fTarget.Seek(Offset,Origin);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.FlushReaders;
var
  i:  Integer;
begin
For i := HighIndex downto LowIndex do
  fLayers[i].Reader.Flush;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.FlushWriters;
var
  i:  Integer;
begin
For i := HighIndex downto LowIndex do
  fLayers[i].Writer.Flush;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.InitializeLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    fLayers[Index].Reader.Counterpart := fLayers[Index].Writer;
    fLayers[Index].Writer.Counterpart := fLayers[Index].Reader;
    ConnectLayer(Index);
    fLayers[Index].Reader.InternalInit;
    fLayers[Index].Writer.InternalInit;
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.InitializeLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.FinalizeLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    fLayers[Index].Reader.InternalFinal;
    fLayers[Index].Writer.InternalFinal;
    DisconnectLayer(Index);
    fLayers[Index].Reader.SetCounterpart(nil);
    fLayers[Index].Writer.SetCounterpart(nil);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.FinalizeLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.ConnectLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    // connect layer output
    If Index > LowIndex then
      begin
        fLayers[Index].Reader.SeekConnection := fLayers[Pred(Index)].Reader.SeekIn;
        fLayers[Index].Reader.ReadConnection := fLayers[Pred(Index)].Reader.ReadIn;
        fLayers[Index].Writer.SeekConnection := fLayers[Pred(Index)].Writer.SeekIn;
        fLayers[Index].Writer.WriteConnection := fLayers[Pred(Index)].Writer.WriteIn;
      end
    else
      begin
        fLayers[Index].Reader.SeekConnection := Self.SeekOut;
        fLayers[Index].Reader.ReadConnection := Self.ReadOut;
        fLayers[Index].Writer.SeekConnection := Self.SeekOut;
        fLayers[Index].Writer.WriteConnection := Self.WriteOut;
      end;
    // connect layer input
    If Index < HighIndex then
      begin
        fLayers[Succ(Index)].Reader.SeekConnection := fLayers[Index].Reader.SeekIn;
        fLayers[Succ(Index)].Reader.ReadConnection := fLayers[Index].Reader.ReadIn;
        fLayers[Succ(Index)].Writer.SeekConnection := fLayers[Index].Writer.SeekIn;
        fLayers[Succ(Index)].Writer.WriteConnection := fLayers[Index].Writer.WriteIn;
      end;
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.ConnectLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.DisconnectLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    If Index < HighIndex then
      begin
        fLayers[Succ(Index)].Reader.ReadConnection := fLayers[Index].Reader.ReadConnection;
        fLayers[Succ(Index)].Reader.Seekconnection := fLayers[Index].Reader.Seekconnection;
        fLayers[Succ(Index)].Writer.WriteConnection := fLayers[Index].Writer.WriteConnection;
        fLayers[Succ(Index)].Writer.Seekconnection := fLayers[Index].Writer.Seekconnection;
      end;
    fLayers[Index].Reader.SeekConnection := nil;
    fLayers[Index].Reader.ReadConnection := nil;
    fLayers[Index].Writer.SeekConnection := nil;
    fLayers[Index].Writer.WriteConnection := nil;
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.ConnectLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Initialize;
begin
// target is set in constructor
fMode := lsmUndefined;
fOwnsTarget := False;
SetLength(fLayers,0);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Finalize;
begin
Clear;  // also calls flush
If fOwnsTarget then
  fTarget.Free;
end;

{-------------------------------------------------------------------------------
    TLayeredStream - public methods
-------------------------------------------------------------------------------}

constructor TLayeredStream.Create(Target: TStream);
begin
inherited Create;
fTarget := Target;
Initialize;
end;

//------------------------------------------------------------------------------

constructor TLayeredStream.Create(Target: TStream; Layers: array of TLSLayerConstruct);
var
  i:  Integer;
begin
Create(Target);
SetLength(fLayers,Length(Layers));
For i := Low(fLayers) to High(fLayers) do
  begin
    fLayers[i].Name := Layers[i].Name;
    fLayers[i].Reader := Layers[i].Reader.Create(Layers[i].ReaderParams);
    fLayers[i].Writer := Layers[i].Writer.Create(Layers[i].WriterParams);
  end;
// InitializeLayer must be called after all objects are created
For i := Low(fLayers) to High(fLayers) do
  InitializeLayer(i);
end;

//------------------------------------------------------------------------------

destructor TLayeredStream.Destroy;
begin
Finalize;
inherited;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.LowIndex: Integer;
begin
Result := Low(fLayers);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.HighIndex: Integer;
begin
Result := High(fLayers);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.CheckIndex(Index: Integer): Boolean;
begin
Result := (Index >= LowIndex) and (Index <= HighIndex);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.IndexOf(const LayerName: String): Integer;
var
  i:  Integer;
begin
Result := -1;
For i := LowIndex to HighIndex do
  If AnsiSameStr(fLayers[i].Name,LayerName) then
    begin
      Result := i;
      Break{For i};
    end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.IndexOf(LayerObjectClass: TLSLayerObjectClass): Integer;
var
  i:  Integer;
begin
Result := -1;
For i := LowIndex to HighIndex do
  If (fLayers[i].Reader is LayerObjectClass) or (fLayers[i].Writer is LayerObjectClass) then
    begin
      Result := i;
      Break{For i};
    end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.IndexOf(LayerObject: TLSLayerObjectBase): Integer;
var
  i:  Integer;
begin
Result := -1;
For i := LowIndex to HighIndex do
  If (fLayers[i].Reader = LayerObject) or (fLayers[i].Writer = LayerObject) then
    begin
      Result := i;
      Break{For i};
    end;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Find(const LayerName: String; out Index: Integer): Boolean;
begin
Index := IndexOf(LayerName);
Result := CheckIndex(Index);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Find(LayerObjectClass: TLSLayerObjectClass; out Index: Integer): Boolean;
begin
Index := IndexOf(LayerObjectClass);
Result := CheckIndex(Index);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Find(LayerObject: TLSLayerObjectBase; out Index: Integer): Boolean;
begin
Index := IndexOf(LayerObject);
Result := CheckIndex(Index);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Add(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer;
begin
SetLength(fLayers,Length(fLayers) + 1);
Result := High(fLayers);
fLayers[Result].Name := Name;
fLayers[Result].Reader := Reader.Create(ReaderParams);
fLayers[Result].Writer := Writer.Create(WriterParams);
InitializeLayer(Result);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Add(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer;
begin
Result := Add('',Reader,Writer,ReaderParams,WriterParams);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Add(LayerConstruct: TLSLayerConstruct): Integer;
begin
Result := Add(LayerConstruct.Name,LayerConstruct.Reader,LayerConstruct.Writer,LayerConstruct.ReaderParams,LayerConstruct.WriterParams);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Insert(Index: Integer; const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil);
var
  i:  Integer;
begin
If CheckIndex(Index) then
  begin
    SetLength(fLayers,Length(fLayers) + 1);
    For i := High(fLayers) downto Succ(Index) do
      fLayers[i] := fLayers[i - 1];  
    fLayers[Index].Name := Name;
    fLayers[Index].Reader := Reader.Create(ReaderParams);
    fLayers[Index].Writer := Writer.Create(WriterParams);
    InitializeLayer(Index);
  end
else If Index = Count then
  Add(Name,Reader,Writer,ReaderParams,WriterParams)
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.Insert: Index (%d) out of bounds.',[Index]);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

procedure TLayeredStream.Insert(Index: Integer; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil);
begin
Insert(Index,'',Reader,Writer,ReaderParams,WriterParams);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

procedure TLayeredStream.Insert(Index: Integer; LayerConstruct: TLSLayerConstruct);
begin
Insert(Index,LayerConstruct.Name,LayerConstruct.Reader,LayerConstruct.Writer,LayerConstruct.ReaderParams,LayerConstruct.WriterParams);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Remove(const LayerName: String): Integer;
begin
Result := IndexOf(LayerName);
If CheckIndex(Result) then
  Delete(Result);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Remove(LayerObjectClass: TLSLayerObjectClass): Integer;
begin
Result := IndexOf(LayerObjectClass);
If CheckIndex(Result) then
  Delete(Result);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Remove(LayerObject: TLSLayerObjectBase): Integer;
begin
Result := IndexOf(LayerObject);
If CheckIndex(Result) then
  Delete(Result);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Delete(Index: Integer);
var
  i:  Integer;
begin
If CheckIndex(Index) then
  begin
    FinalizeLayer(Index);  // flushes both reader and writer
    fLayers[Index].Reader.Free;
    fLayers[Index].Writer.Free;
    For i := Index to Pred(HighIndex) do
      fLayers[i] := fLayers[i + 1];
    SetLength(fLayers,Length(fLayers) - 1);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.Delete: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Clear;
var
  i:  Integer;
begin
Flush;
For i := HighIndex downto LowIndex do
  begin
    FinalizeLayer(i);
    fLayers[i].Reader.Free;
    fLayers[i].Writer.Free;
  end;
SetLength(fLayers,0);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Init;
var
  i:  Integer;
begin
For i := LowIndex to HighIndex do
  begin
    fLayers[i].Reader.Init;
    fLayers[i].Writer.Init;
  end;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Final;
var
  i:  Integer;
begin
For i := HighIndex downto LowIndex do
  begin
    fLayers[i].Reader.Final;
    fLayers[i].Writer.Final;
  end;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Flush;
begin
case fMode of
  lsmRead:  FlushReaders;
  lsmWrite: FlushWriters;
else
 {lsmUndefined,lsmSeek}
  // do nothing
end;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Seek(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := SeekIn(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Read(var Buffer; Count: LongInt): LongInt;
begin
Result := ReadIn(Buffer,Count);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Write(const Buffer; Count: LongInt): LongInt;
begin
Result := WriteIn(Buffer,Count);
end;

end.

