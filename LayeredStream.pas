unit LayeredStream;

interface

uses
  SysUtils, Classes,
  AuxTypes, AuxClasses, SimpleNamedValues;

type
  ELSException = class(Exception);

  ELSIndexOutOfBounds    = class(ELSException);
  ELSInvalidConnection   = class(ELSException);
  ELSLayerIntegrityError = class(ELSException);

{===============================================================================
--------------------------------------------------------------------------------
                               TLSLayerObjectBase
--------------------------------------------------------------------------------
===============================================================================}

  TLSLayerObjectType = (lotUndefined,lotReader,lotWriter);

  TLSLayerObjectBehavior = (
  {
    lobPassthrough

    Data are directly passing through and are not changed or delayed in any way.
  }
    lobPassthrough,
  {
    lobObserver

    Data are observed and some processing is done on them (eg. hashing,
    statistics, ...).
    This behavior does not tell whether the data are in any way changed or
    delayed, it merely indicates that some processing is done on them.
  }
    lobObserver,
  {
    lobProcessor

    Data are changed in some way (eg. compressed, encrypted, ...).
  }
    lobProcessor,
  {
    lobSplitter

    At least part of the data, and possibly all of them, is passed to some side
    channel - but they are not removed from the streaming, merely copied.
  }
    lobSplitter,
  {
    lobJoiner

    Some data are added to the streaming from a side channel.
  }
    lobJoiner,
  {
    lobAccumulator

    Data are accumulated in the layer and are not directly streamed. They might
    be streamed at some given point or at the end of processing (finalization).
    Typical case is buffering.
  }
    lobAccumulator,
  {
    lobConsumer

    Data are at least in part consumed by the layer - that is, some or all of
    the data are removed from the streaming.
  }
    lobConsumer,
  {
    lobGenerator

    New data can be generated by the layer and added to the streaming. It is
    even possible that the layer is producing data with no input at all.
  }
    lobGenerator,

  {
    lobOther

    Some unspecified processing that does not fit any of the above options.
  }
    lobOther);

  TLSLayerObjectKind = set of TLSLayerObjectBehavior;

{
  types used to return information about accepted parameters
}
  TLSLayerObjectParamReceiver = (loprConstructor,loprInitializer);

  TLSLayerObjectParamReceivers = set of TLSLayerObjectParamReceiver;

  TLSLayerObjectParam = record
    Name:        String;
    ValueType:   TSNVNamedValueType;
    Receivers:   TLSLayerObjectParamReceivers;
    Description: String;
  end;

  TLSLayerObjectParams = array of TLSLayerObjectParam;

Function LayerObjectParam(const Name: String; ValueType: TSNVNamedValueType; Receivers: TLSLayerObjectParamReceivers; const Description: String): TLSLayerObjectParam;

{
  connection events
}
type
  TLSLayerObjectSeekConnection = Function(const Offset: Int64; Origin: TSeekOrigin): Int64 of object;
  TLSLayerObjectReadConnection = Function(out Buffer; Size: LongInt): LongInt of object;
  TLSLayerObjectWriteConnection = Function(const Buffer; Size: LongInt): LongInt of object;

{===============================================================================
    TLSLayerObjectBase - class declaration
===============================================================================}
type
  TLSLayerObjectBase = class(TCustomObject)
  protected
    fCounterpart:     TLSLayerObjectBase; // the orher object in layer pair
    fSeekConnection:  TLSLayerObjectSeekConnection;
    fActive:          Boolean;
    procedure SetCounterpart(Value: TLSLayerObjectBase); virtual;
    procedure SetActive(Value: Boolean); virtual;
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual; abstract;
    Function SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    procedure Initialize(Params: TSimpleNamedValues); virtual;
    procedure Finalize; virtual;
  public
    class Function LayerObjectType: TLSLayerObjectType; virtual;      // reader/writer
    class Function LayerObjectKind: TLSLayerObjectKind; virtual;      // set of behaviors
    class Function LayerObjectParams: TLSLayerObjectParams; virtual;  // list of accepted parameters
    constructor Create(Params: TSimpleNamedValues);
    destructor Destroy; override;
    procedure InternalInit; virtual;  // called by layered stream after the layer is set up, do not call yourself!
    procedure InternalFinal; virtual; // called by layered stream before the layer is removed, calls flush, do not call yourself!
  {
    Note that calling Init or Final is not mandatory, they are here only for
    those layer objects that really do need them.
  }
    procedure Init(Params: TSimpleNamedValues = nil); virtual;  // can be called any time, multiple times
    procedure Final; virtual;                                   // -//-
    procedure Flush; virtual;
    Function SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    property Counterpart: TLSLayerObjectBase read fCounterpart write SetCounterpart;
    property SeekConnection: TLSLayerObjectSeekConnection read fSeekConnection write fSeekConnection;
    property Active: Boolean read fActive write SetActive;
  end;

  TLSLayerObjectClass = class of TLSLayerObjectBase;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLSLayerReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerReader - class declaration
===============================================================================}
type
  TLSLayerReader = class(TLSLayerObjectBase)
  protected
    fReadConnection:  TLSLayerObjectReadConnection;
    Function ReadActive(out Buffer; Size: LongInt): LongInt; virtual; abstract;
    Function ReadOut(out Buffer; Size: LongInt): LongInt; virtual;
  public
    class Function LayerObjectType: TLSLayerObjectType; override;
    Function ReadIn(out Buffer; Size: LongInt): LongInt; virtual;
    property ReadConnection: TLSLayerObjectReadConnection read fReadConnection write fReadConnection;
  end;

  TLSLayerReaderClass = class of TLSLayerReader;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLSLayerWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerWriter - class declaration
===============================================================================}
type
  TLSLayerWriter = class(TLSLayerObjectBase)
  protected
    fWriteConnection: TLSLayerObjectWriteConnection;
    Function WriteActive(const Buffer; Size: LongInt): LongInt; virtual; abstract;
    Function WriteOut(const Buffer; Size: LongInt): LongInt; virtual;
  public
    class Function LayerObjectType: TLSLayerObjectType; override;
    Function WriteIn(const Buffer; Size: LongInt): LongInt; virtual;
    property WriteConnection: TLSLayerObjectWriteConnection read fWriteConnection write fWriteConnection;
  end;

  TLSLayerWriterClass = class of TLSLayerWriter;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLayeredStream
--------------------------------------------------------------------------------
===============================================================================}
type
  TLayeredStreamMode = (lsmUndefined,lsmSeek,lsmRead,lsmWrite);

  TLSLayer = record
    Name:   String;
    Reader: TLSLayerReader;
    Writer: TLSLayerWriter;
  end;

  // for use in constructor...
  TLSLayerConstruct = record
    Name:         String;
    Reader:       TLSLayerReaderClass;
    Writer:       TLSLayerWriterClass;
    ReaderParams: TSimpleNamedValues;
    WriterParams: TSimpleNamedValues;
  end;

Function LayerConstruct(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): TLSLayerConstruct; overload;
Function LayerConstruct(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass): TLSLayerConstruct; overload;

{===============================================================================
    TLayeredStream - class declaration
===============================================================================}

type
  TLayeredStream = class(TStream)
  private
    fMode:        TLayeredStreamMode;
    fTarget:      TStream;
    fOwnsTarget:  Boolean;
    fLayers:      array of TLSLayer;
    Function GetLayerCount: Integer;
    Function GetLayer(Index: Integer): TLSLayer;
    Function GetLayerName(Index: Integer): String;
    procedure SetLayerName(Index: Integer; const Value: String);
    Function GetLayerActive(Index: Integer): Boolean;
    procedure SetLayerActive(Index: Integer; Value: Boolean);
  protected
    Function ChangeMode(NewMode: TLayeredStreamMode): TLayeredStreamMode; virtual;  // returns previous mode
    Function ReadIn(out Buffer; Size: LongInt): LongInt; virtual;
    Function ReadOut(out Buffer; Size: LongInt): LongInt; virtual;
    Function WriteIn(const Buffer; Size: LongInt): LongInt; virtual;
    Function WriteOut(const Buffer; Size: LongInt): LongInt; virtual;
    Function SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    Function SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    procedure FlushReaders; virtual;    // flushed from top to botom
    procedure FlushWriters; virtual;    // -//-
    procedure InitializeLayer(Index: Integer); virtual;
    procedure FinalizeLayer(Index: Integer); virtual;
    procedure ConnectLayer(Index: Integer); virtual;
    procedure DisconnectLayer(Index: Integer); virtual;
    procedure Initialize; virtual;
    procedure Finalize; virtual;
  public
    constructor Create(Target: TStream); overload;
    constructor Create(Target: TStream; Layers: array of TLSLayerConstruct); overload;
    destructor Destroy; override;
    // layers list index
    Function LowIndex: Integer; virtual;
    Function HighIndex: Integer; virtual;
    Function CheckIndex(Index: Integer): Boolean; virtual;
    Function IndexOf(const LayerName: String): Integer; overload; virtual;    // case sensitive!
    Function IndexOf(LayerObjectClass: TLSLayerObjectClass): Integer; overload; virtual;
    Function IndexOf(LayerObject: TLSLayerObjectBase): Integer; overload; virtual;
    Function Find(const LayerName: String; out Index: Integer): Boolean; overload; virtual;
    Function Find(LayerObjectClass: TLSLayerObjectClass; out Index: Integer): Boolean; overload; virtual;
    Function Find(LayerObject: TLSLayerObjectBase; out Index: Integer): Boolean; overload; virtual;
    Function Add(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer; overload; virtual;
    Function Add(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer; overload; virtual;
    Function Add(LayerConstruct: TLSLayerConstruct): Integer; overload; virtual;
    procedure Insert(Index: Integer; const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil); overload; virtual;
    procedure Insert(Index: Integer; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil); overload; virtual;
    procedure Insert(Index: Integer; LayerConstruct: TLSLayerConstruct); overload; virtual;
    Function Remove(const LayerName: String): Integer; overload; virtual;
    Function Remove(LayerObjectClass: TLSLayerObjectClass): Integer; overload; virtual;
    Function Remove(LayerObject: TLSLayerObjectBase): Integer; overload; virtual;  
    procedure Delete(Index: Integer); virtual;
    procedure Clear; virtual;
    // layers methods
    procedure Init; virtual;  // initilizes all layers from first to last
    procedure Final; virtual; // finalizes all layers from last to first
    procedure Flush; virtual; // flushes all layers according to mode (FlushReaders, FlushWriters)
    {$message 'implement'}
    //procedure Init(Index: Integer; ReaderParams, WriterParams: TSimpleNamedValues = nil); overload; virtual;
    //procedure Final(Index: Integer); overload; virtual;
    //procedure Flush(Index: Integer); overload; virtual;
    //procedure InitReader(Index: Integer; Params: TSimpleNamedValues = nil); virtual;
    //procedure InitWriter(Index: Integer; Params: TSimpleNamedValues = nil); virtual;
    //procedure FinalReader(Index: Integer); virtual;
    //procedure FinalWriter(Index: Integer); virtual;
    //procedure FlushReader(Index: Integer);
    //procedure FlushWriter(Index: Integer);
    // stream methods
    Function Seek(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function Read(var Buffer; Count: LongInt): LongInt; override;
    Function Write(const Buffer; Count: LongInt): LongInt; override;
    // properties
    property Mode: TLayeredStreamMode read fMode;
    property Target: TStream read fTarget;
    property OwnsTarget: Boolean read fOwnsTarget write fOwnsTarget;
    property Count: Integer read GetLayerCount;
    property Layers[Index: Integer]: TLSLayer read GetLayer; default;
    property LayerNames[Index: Integer]: String read GetLayerName write SetLayerName;
    property LayerActive[Index: Integer]: Boolean read GetLayerActive write SetLayerActive;
  end;      

{===============================================================================
--------------------------------------------------------------------------------
                               TPassthroughReader                                                             
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TPassthroughReader - class declaration
===============================================================================}

type
  TPassthroughReader = class(TLSLayerReader)
  protected
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function ReadActive(out Buffer; Size: LongInt): LongInt; override;
  public
    class Function LayerObjectKind: TLSLayerObjectKind; override;
  end;

{===============================================================================
--------------------------------------------------------------------------------
                               TPassthroughWriter                                                             
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TPassthroughWriter - class declaration
===============================================================================}
type
  TPassthroughWriter = class(TLSLayerWriter)
  protected
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function WriteActive(const Buffer; Size: LongInt): LongInt; override;
  public
    class Function LayerObjectKind: TLSLayerObjectKind; override;
  end;

{===============================================================================
--------------------------------------------------------------------------------
                                   TStatReader
--------------------------------------------------------------------------------
===============================================================================}
type
  TStatsPerByte = array[Byte] of UInt64;

{===============================================================================
    TStatReader - class declaration
===============================================================================}
type
  TStatReader = class(TLSLayerReader)
  private
    fFullStats:     Boolean;
    fCounter:       UInt64;
    fByteCounters:  TStatsPerByte;
  protected
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function ReadActive(out Buffer; Size: LongInt): LongInt; override;
    procedure Initialize(Params: TSimpleNamedValues); override;
    procedure ClearStats; virtual;
  public
    class Function LayerObjectKind: TLSLayerObjectKind; override;
    class Function LayerObjectParams: TLSLayerObjectParams; override;
    procedure Init(Params: TSimpleNamedValues); overload; override;
    property Counter: UInt64 read fCounter;
    property ByteCounters: TStatsPerByte read fByteCounters;
  end;

{===============================================================================
--------------------------------------------------------------------------------
                                   TStatWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TStatWriter - class declaration
===============================================================================}
type
  TStatWriter = class(TLSLayerWriter)
  private
    fFullStats:     Boolean;
    fCounter:       UInt64;
    fByteCounters:  TStatsPerByte;
  protected
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function WriteActive(const Buffer; Size: LongInt): LongInt; override;
    procedure Initialize(Params: TSimpleNamedValues); override;
    procedure ClearStats; virtual;
  public
    class Function LayerObjectKind: TLSLayerObjectKind; override;
    class Function LayerObjectParams: TLSLayerObjectParams; override;
    procedure Init(Params: TSimpleNamedValues); overload; override;
    property Counter: UInt64 read fCounter;
    property ByteCounters: TStatsPerByte read fByteCounters;
  end;

{===============================================================================
--------------------------------------------------------------------------------
                                  TBufferReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TBufferReader - class declaration
===============================================================================}
type
  TBufferReader = class(TLSLayerReader)
  private
    fMemory:  Pointer;
    fSize:    LongInt;
    fUsed:    LongInt;
  protected
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function ReadActive(out Buffer; Size: LongInt): LongInt; override;
    procedure Initialize(Params: TSimpleNamedValues); override;
    procedure Finalize; override;
  public
    class Function LayerObjectKind: TLSLayerObjectKind; override;
    //class Function LayerObjectParams: TLSLayerObjectParams; override;
    procedure Flush; override;
    property Memory: Pointer read fMemory;
    property Size: LongInt read fSize;
    property Used: LongInt read fUsed;
  end;

{===============================================================================
--------------------------------------------------------------------------------
                                  TBufferWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TBufferWriter - class declaration
===============================================================================}
type
  TBufferWriter = class(TLSLayerWriter)
  private
    fAllowPartialWrites:  Boolean;
    fMemory:              Pointer;
    fSize:                LongInt;
    fUsed:                LongInt;
  protected
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
    Function WriteActive(const Buffer; Size: LongInt): LongInt; override;
    procedure Initialize(Params: TSimpleNamedValues); override;
    procedure Finalize; override;
  public
    class Function LayerObjectKind: TLSLayerObjectKind; override;
    class Function LayerObjectParams: TLSLayerObjectParams; override;
    procedure Flush; override;
    property AllowPartialWrites: Boolean read fAllowPartialWrites write fAllowPartialWrites;
    property Memory: Pointer read fMemory;
    property Size: LongInt read fSize;
    property Used: LongInt read fUsed;
  end;

implementation

uses
  Math;

{===============================================================================
--------------------------------------------------------------------------------
                               TLSLayerObjectBase
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerObjectBase - Auxiliary functions
===============================================================================}

Function LayerObjectParam(const Name: String; ValueType: TSNVNamedValueType; Receivers: TLSLayerObjectParamReceivers; const Description: String): TLSLayerObjectParam;
begin
Result.Name := Name;
Result.ValueType := ValueType;
Result.Receivers := Receivers;
Result.Description := Description;
end;

{===============================================================================
    TLSLayerObjectBase - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerObjectBase - protected methods
-------------------------------------------------------------------------------}

procedure TLSLayerObjectBase.SetCounterpart(Value: TLSLayerObjectBase);
begin
fCounterpart := Value;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.SetActive(Value: Boolean);
begin
If Value <> fActive then
  begin
    If not Value then // deactivating, do flush
      Flush;
    fActive := Value;
  end;
end;

//------------------------------------------------------------------------------

Function TLSLayerObjectBase.SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := 0;
If Assigned(fSeekConnection) then
  Result := fSeekConnection(Offset,Origin)
else
  ELSInvalidConnection.Create('TLSLayerObjectBase.SeekOut: Seek connection not assigned.');
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Initialize(Params: TSimpleNamedValues);
begin
fCounterpart := nil;
fSeekConnection := nil;
fActive := True;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Finalize;
begin
// no action
end;

{-------------------------------------------------------------------------------
    TLSLayerObjectBase - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerObjectBase.LayerObjectType: TLSLayerObjectType;
begin
Result := lotUndefined;
end;

//------------------------------------------------------------------------------

class Function TLSLayerObjectBase.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [];
end;

//------------------------------------------------------------------------------

class Function TLSLayerObjectBase.LayerObjectParams: TLSLayerObjectParams;
begin
SetLength(Result,0);
end;

//------------------------------------------------------------------------------

constructor TLSLayerObjectBase.Create(Params: TSimpleNamedValues);
begin
inherited Create;
Initialize(Params);
end;

//------------------------------------------------------------------------------

destructor TLSLayerObjectBase.Destroy;
begin
Finalize;
inherited;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.InternalInit;
begin
// no action
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.InternalFinal;
begin
Flush;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Init(Params: TSimpleNamedValues = nil);
begin
// nothing to do
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Final;
begin
// nothing to do
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Flush;
begin
// nothing to do
end;

//------------------------------------------------------------------------------

Function TLSLayerObjectBase.SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
If fActive then
  Result := SeekActive(Offset,Origin)
else
  Result := SeekOut(Offset,Origin);
end;

{===============================================================================
--------------------------------------------------------------------------------
                              TLSLayerReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerReader - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerReader - protected methods
-------------------------------------------------------------------------------}

Function TLSLayerReader.ReadOut(out Buffer; Size: LongInt): LongInt;
begin
Result := 0;
If Assigned(fReadConnection) then
  Result := fReadConnection(Buffer,Size)
else
  ELSInvalidConnection.Create('TLSLayerReader.ReadOut: Read connection not assigned.');
end;

{-------------------------------------------------------------------------------
    TLSLayerReader - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerReader.LayerObjectType: TLSLayerObjectType;
begin
Result := lotReader;
end;

//------------------------------------------------------------------------------

Function TLSLayerReader.ReadIn(out Buffer; Size: LongInt): LongInt;
begin
If fActive then
  Result := ReadActive(Buffer,Size)
else
  Result := ReadOut(Buffer,Size);
end;

{===============================================================================
--------------------------------------------------------------------------------
                              TLSLayerWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerWriter - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerWriter - protected methods
-------------------------------------------------------------------------------}

Function TLSLayerWriter.WriteOut(const Buffer; Size: LongInt): LongInt;
begin
Result := 0;
If Assigned(fWriteConnection) then
  Result := fWriteConnection(Buffer,Size)
else
  ELSInvalidConnection.Create('TLSLayerWriter.WriteOut: Write connection not assigned.');
end;

{-------------------------------------------------------------------------------
    TLSLayerWriter - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerWriter.LayerObjectType: TLSLayerObjectType;
begin
Result := lotWriter;
end;

//------------------------------------------------------------------------------

Function TLSLayerWriter.WriteIn(const Buffer; Size: LongInt): LongInt;
begin
If fActive then
  Result := WriteActive(Buffer,Size)
else
  Result := WriteOut(Buffer,Size);
end;


{===============================================================================
--------------------------------------------------------------------------------
                                 TLayeredStream
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLayeredStream - Auxiliary functions
===============================================================================}

Function LayerConstruct(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): TLSLayerConstruct;
begin
Result.Name := Name;
Result.Reader := Reader;
Result.Writer := Writer;
Result.ReaderParams := ReaderParams;
Result.WriterParams := WriterParams;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function LayerConstruct(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass): TLSLayerConstruct;
begin
Result := LayerConstruct('',Reader,Writer);
end;

{===============================================================================
    TLayeredStream - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLayeredStream - pritave methods
-------------------------------------------------------------------------------}

Function TLayeredStream.GetLayerCount: Integer;
begin
Result := Length(fLayers);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.GetLayer(Index: Integer): TLSLayer;
begin
If CheckIndex(Index) then
  Result := fLayers[Index]
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.GetLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.GetLayerName(Index: Integer): String;
begin
If CheckIndex(Index) then
  Result := fLayers[Index].Name
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.GetLayerName: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.SetLayerName(Index: Integer; const Value: String);
begin
If CheckIndex(Index) then
  fLayers[Index].Name := Value
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.SetLayerName: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.GetLayerActive(Index: Integer): Boolean;
begin
If CheckIndex(Index) then
  begin
    If fLayers[Index].Reader.Active = fLayers[Index].Writer.Active then
      Result := fLayers[Index].Reader.Active
    else
      raise ELSLayerIntegrityError.CreateFmt('TLayeredStream.GetLayerActive: Layer #%d active setting mismatch.',[Index]);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.GetLayerActive: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.SetLayerActive(Index: Integer; Value: Boolean);
begin
If CheckIndex(Index) then
  begin
    If fLayers[Index].Reader.Active = fLayers[Index].Writer.Active then
      begin
        fLayers[Index].Reader.Active := Value;
        fLayers[Index].Writer.Active := Value;
      end
    else raise ELSLayerIntegrityError.CreateFmt('TLayeredStream.SetLayerActive: Layer #%d active setting mismatch.',[Index]);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.SetLayerActive: Index (%d) out of bounds.',[Index]);
end;

{-------------------------------------------------------------------------------
    TLayeredStream - protected methods
-------------------------------------------------------------------------------}

Function TLayeredStream.ChangeMode(NewMode: TLayeredStreamMode): TLayeredStreamMode;
begin
Result := fMode;
If fMode <> NewMode then
  begin
    Flush;
    fMode := NewMode;
  end;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.ReadIn(out Buffer; Size: LongInt): LongInt;
begin
ChangeMode(lsmRead);
If Length(fLayers) > 0 then
  Result := fLayers[HighIndex].Reader.ReadIn(Buffer,Size)
else
  Result := ReadOut(Buffer,Size);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.ReadOut(out Buffer; Size: LongInt): LongInt;
begin
Result := fTarget.Read(Buffer,Integer(Size));
end;

//------------------------------------------------------------------------------

Function TLayeredStream.WriteIn(const Buffer; Size: LongInt): LongInt;
begin
ChangeMode(lsmWrite);
If Length(fLayers) > 0 then
  Result := fLayers[HighIndex].Writer.WriteIn(Buffer,Size)
else
  Result := WriteOut(Buffer,Size);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.WriteOut(const Buffer; Size: LongInt): LongInt;
begin
Result := fTarget.Write(Buffer,Integer(Size));
end;

//------------------------------------------------------------------------------

Function TLayeredStream.SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64;
var
  OldMode:  TLayeredStreamMode;
begin
OldMode := ChangeMode(lsmSeek);
If Length(fLayers) > 0 then
  begin
    case OldMode of
      lsmRead:  Result := fLayers[HighIndex].Reader.SeekIn(Offset,Origin);
      lsmWrite: Result := fLayers[HighIndex].Writer.SeekIn(Offset,Origin);
    else
     {lsmUndefined,lsmSeek}
      Result := SeekOut(Offset,Origin);
    end;
  end
else Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := fTarget.Seek(Offset,Origin);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.FlushReaders;
var
  i:  Integer;
begin
For i := HighIndex downto LowIndex do
  fLayers[i].Reader.Flush;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.FlushWriters;
var
  i:  Integer;
begin
For i := HighIndex downto LowIndex do
  fLayers[i].Writer.Flush;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.InitializeLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    fLayers[Index].Reader.Counterpart := fLayers[Index].Writer;
    fLayers[Index].Writer.Counterpart := fLayers[Index].Reader;
    ConnectLayer(Index);
    fLayers[Index].Reader.InternalInit;
    fLayers[Index].Writer.InternalInit;
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.InitializeLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.FinalizeLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    fLayers[Index].Reader.InternalFinal;
    fLayers[Index].Writer.InternalFinal;
    DisconnectLayer(Index);
    fLayers[Index].Reader.SetCounterpart(nil);
    fLayers[Index].Writer.SetCounterpart(nil);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.FinalizeLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.ConnectLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    // connect layer output
    If Index > LowIndex then
      begin
        fLayers[Index].Reader.SeekConnection := fLayers[Pred(Index)].Reader.SeekIn;
        fLayers[Index].Reader.ReadConnection := fLayers[Pred(Index)].Reader.ReadIn;
        fLayers[Index].Writer.SeekConnection := fLayers[Pred(Index)].Writer.SeekIn;
        fLayers[Index].Writer.WriteConnection := fLayers[Pred(Index)].Writer.WriteIn;
      end
    else
      begin
        fLayers[Index].Reader.SeekConnection := Self.SeekOut;
        fLayers[Index].Reader.ReadConnection := Self.ReadOut;
        fLayers[Index].Writer.SeekConnection := Self.SeekOut;
        fLayers[Index].Writer.WriteConnection := Self.WriteOut;
      end;
    // connect layer input
    If Index < HighIndex then
      begin
        fLayers[Succ(Index)].Reader.SeekConnection := fLayers[Index].Reader.SeekIn;
        fLayers[Succ(Index)].Reader.ReadConnection := fLayers[Index].Reader.ReadIn;
        fLayers[Succ(Index)].Writer.SeekConnection := fLayers[Index].Writer.SeekIn;
        fLayers[Succ(Index)].Writer.WriteConnection := fLayers[Index].Writer.WriteIn;
      end;
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.ConnectLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.DisconnectLayer(Index: Integer);
begin
If CheckIndex(Index) then
  begin
    If Index < HighIndex then
      begin
        fLayers[Succ(Index)].Reader.ReadConnection := fLayers[Index].Reader.ReadConnection;
        fLayers[Succ(Index)].Reader.Seekconnection := fLayers[Index].Reader.Seekconnection;
        fLayers[Succ(Index)].Writer.WriteConnection := fLayers[Index].Writer.WriteConnection;
        fLayers[Succ(Index)].Writer.Seekconnection := fLayers[Index].Writer.Seekconnection;
      end;
    fLayers[Index].Reader.SeekConnection := nil;
    fLayers[Index].Reader.ReadConnection := nil;
    fLayers[Index].Writer.SeekConnection := nil;
    fLayers[Index].Writer.WriteConnection := nil;
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.ConnectLayer: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Initialize;
begin
// target is set in constructor
fMode := lsmUndefined;
fOwnsTarget := False;
SetLength(fLayers,0);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Finalize;
begin
Clear;  // also calls flush
If fOwnsTarget then
  fTarget.Free;
end;

{-------------------------------------------------------------------------------
    TLayeredStream - public methods
-------------------------------------------------------------------------------}

constructor TLayeredStream.Create(Target: TStream);
begin
inherited Create;
fTarget := Target;
Initialize;
end;

//------------------------------------------------------------------------------

constructor TLayeredStream.Create(Target: TStream; Layers: array of TLSLayerConstruct);
var
  i:  Integer;
begin
Create(Target);
SetLength(fLayers,Length(Layers));
For i := Low(fLayers) to High(fLayers) do
  begin
    fLayers[i].Name := Layers[i].Name;
    fLayers[i].Reader := Layers[i].Reader.Create(Layers[i].ReaderParams);
    fLayers[i].Writer := Layers[i].Writer.Create(Layers[i].WriterParams);
  end;
// InitializeLayer must be called after all objects are created
For i := Low(fLayers) to High(fLayers) do
  InitializeLayer(i);
end;

//------------------------------------------------------------------------------

destructor TLayeredStream.Destroy;
begin
Finalize;
inherited;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.LowIndex: Integer;
begin
Result := Low(fLayers);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.HighIndex: Integer;
begin
Result := High(fLayers);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.CheckIndex(Index: Integer): Boolean;
begin
Result := (Index >= LowIndex) and (Index <= HighIndex);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.IndexOf(const LayerName: String): Integer;
var
  i:  Integer;
begin
Result := -1;
For i := LowIndex to HighIndex do
  If AnsiSameStr(fLayers[i].Name,LayerName) then
    begin
      Result := i;
      Break{For i};
    end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.IndexOf(LayerObjectClass: TLSLayerObjectClass): Integer;
var
  i:  Integer;
begin
Result := -1;
For i := LowIndex to HighIndex do
  If (fLayers[i].Reader is LayerObjectClass) or (fLayers[i].Writer is LayerObjectClass) then
    begin
      Result := i;
      Break{For i};
    end;
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.IndexOf(LayerObject: TLSLayerObjectBase): Integer;
var
  i:  Integer;
begin
Result := -1;
For i := LowIndex to HighIndex do
  If (fLayers[i].Reader = LayerObject) or (fLayers[i].Writer = LayerObject) then
    begin
      Result := i;
      Break{For i};
    end;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Find(const LayerName: String; out Index: Integer): Boolean;
begin
Index := IndexOf(LayerName);
Result := CheckIndex(Index);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Find(LayerObjectClass: TLSLayerObjectClass; out Index: Integer): Boolean;
begin
Index := IndexOf(LayerObjectClass);
Result := CheckIndex(Index);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Find(LayerObject: TLSLayerObjectBase; out Index: Integer): Boolean;
begin
Index := IndexOf(LayerObject);
Result := CheckIndex(Index);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Add(const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer;
begin
SetLength(fLayers,Length(fLayers) + 1);
Result := High(fLayers);
fLayers[Result].Name := Name;
fLayers[Result].Reader := Reader.Create(ReaderParams);
fLayers[Result].Writer := Writer.Create(WriterParams);
InitializeLayer(Result);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Add(Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil): Integer;
begin
Result := Add('',Reader,Writer,ReaderParams,WriterParams);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Add(LayerConstruct: TLSLayerConstruct): Integer;
begin
Result := Add(LayerConstruct.Name,LayerConstruct.Reader,LayerConstruct.Writer,LayerConstruct.ReaderParams,LayerConstruct.WriterParams);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Insert(Index: Integer; const Name: String; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil);
var
  i:  Integer;
begin
If CheckIndex(Index) then
  begin
    SetLength(fLayers,Length(fLayers) + 1);
    For i := High(fLayers) downto Succ(Index) do
      fLayers[i] := fLayers[i - 1];  
    fLayers[Index].Name := Name;
    fLayers[Index].Reader := Reader.Create(ReaderParams);
    fLayers[Index].Writer := Writer.Create(WriterParams);
    InitializeLayer(Index);
  end
else If Index = Count then
  Add(Name,Reader,Writer,ReaderParams,WriterParams)
else
  raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.Insert: Index (%d) out of bounds.',[Index]);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

procedure TLayeredStream.Insert(Index: Integer; Reader: TLSLayerReaderClass; Writer: TLSLayerWriterClass; ReaderParams: TSimpleNamedValues = nil; WriterParams: TSimpleNamedValues = nil);
begin
Insert(Index,'',Reader,Writer,ReaderParams,WriterParams);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

procedure TLayeredStream.Insert(Index: Integer; LayerConstruct: TLSLayerConstruct);
begin
Insert(Index,LayerConstruct.Name,LayerConstruct.Reader,LayerConstruct.Writer,LayerConstruct.ReaderParams,LayerConstruct.WriterParams);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Remove(const LayerName: String): Integer;
begin
Result := IndexOf(LayerName);
If CheckIndex(Result) then
  Delete(Result);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Remove(LayerObjectClass: TLSLayerObjectClass): Integer;
begin
Result := IndexOf(LayerObjectClass);
If CheckIndex(Result) then
  Delete(Result);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function TLayeredStream.Remove(LayerObject: TLSLayerObjectBase): Integer;
begin
Result := IndexOf(LayerObject);
If CheckIndex(Result) then
  Delete(Result);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Delete(Index: Integer);
var
  i:  Integer;
begin
If CheckIndex(Index) then
  begin
    FinalizeLayer(Index);  // flushes both reader and writer
    fLayers[Index].Reader.Free;
    fLayers[Index].Writer.Free;
    For i := Index to Pred(HighIndex) do
      fLayers[i] := fLayers[i + 1];
    SetLength(fLayers,Length(fLayers) - 1);
  end
else raise ELSIndexOutOfBounds.CreateFmt('TLayeredStream.Delete: Index (%d) out of bounds.',[Index]);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Clear;
var
  i:  Integer;
begin
Flush;
For i := HighIndex downto LowIndex do
  begin
    FinalizeLayer(i);
    fLayers[i].Reader.Free;
    fLayers[i].Writer.Free;
  end;
SetLength(fLayers,0);
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Init;
var
  i:  Integer;
begin
For i := LowIndex to HighIndex do
  begin
    fLayers[i].Reader.Init;
    fLayers[i].Writer.Init;
  end;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Final;
var
  i:  Integer;
begin
For i := HighIndex downto LowIndex do
  begin
    fLayers[i].Reader.Final;
    fLayers[i].Writer.Final;
  end;
end;

//------------------------------------------------------------------------------

procedure TLayeredStream.Flush;
begin
case fMode of
  lsmRead:  FlushReaders;
  lsmWrite: FlushWriters;
else
 {lsmUndefined,lsmSeek}
  // do nothing
end;
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Seek(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := SeekIn(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Read(var Buffer; Count: LongInt): LongInt;
begin
Result := ReadIn(Buffer,Count);
end;

//------------------------------------------------------------------------------

Function TLayeredStream.Write(const Buffer; Count: LongInt): LongInt;
begin
Result := WriteIn(Buffer,Count);
end;


{===============================================================================
--------------------------------------------------------------------------------
                               TPassthroughReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TPassthroughReader - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TPassthroughReader - protected methods
-------------------------------------------------------------------------------}

Function TPassthroughReader.SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TPassthroughReader.ReadActive(out Buffer; Size: LongInt): LongInt;
begin
Result := ReadOut(Buffer,Size);
end;

{-------------------------------------------------------------------------------
    TPassthroughReader - public methods
-------------------------------------------------------------------------------}

class Function TPassthroughReader.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [lobPassthrough];
end;


{===============================================================================
--------------------------------------------------------------------------------
                               TPassthroughWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TPassthroughWriter - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TPassthroughWriter - protected methods
-------------------------------------------------------------------------------}

Function TPassthroughWriter.SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TPassthroughWriter.WriteActive(const Buffer; Size: LongInt): LongInt;
begin
Result := WriteOut(Buffer,Size);
end;

{-------------------------------------------------------------------------------
    TPassthroughWriter - public methods
-------------------------------------------------------------------------------}

class Function TPassthroughWriter.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [lobPassthrough];
end;

{===============================================================================
--------------------------------------------------------------------------------
                                   TStatReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TStatReader - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TStatReader - protected methods
-------------------------------------------------------------------------------}

Function TStatReader.SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TStatReader.ReadActive(out Buffer; Size: LongInt): LongInt;
var
  BuffPtr:  PByte;
  i:        Integer;
begin
Result := ReadOut(Buffer,Size);
// observe only the amount really read
Inc(fCounter,Result);
If fFullStats then
  begin
    BuffPtr := @Buffer;
    For i := 1 to Result do
      begin
        Inc(fByteCounters[BuffPtr^]);
        Inc(BuffPtr);
      end;
  end;
end;

//------------------------------------------------------------------------------

procedure TStatReader.Initialize(Params: TSimpleNamedValues);
begin
inherited;
fFullStats := False;
ClearStats;
If Assigned(Params) then
  If Params.Exists('TStatReader.FullStats',nvtBool) then
    fFullStats := Params.BoolValue['TStatReader.FullStats'];
end;

//------------------------------------------------------------------------------

procedure TStatReader.ClearStats;
begin
fCounter := 0;
FillChar(fByteCounters,SizeOf(TStatsPerByte),0);
end;

{-------------------------------------------------------------------------------
    TStatReader - public methods
-------------------------------------------------------------------------------}

class Function TStatReader.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [lobPassthrough,lobObserver];
end;

//------------------------------------------------------------------------------

class Function TStatReader.LayerObjectParams: TLSLayerObjectParams;
begin
SetLength(Result,2);
Result[0] := LayerObjectParam('TStatReader.FullStats',nvtBool,[loprConstructor,loprInitializer],'Observe all statistics');
Result[1] := LayerObjectParam('TStatReader.KeepStats',nvtBool,[loprInitializer],'Keep current statistics');
end;

//------------------------------------------------------------------------------

procedure TStatReader.Init(Params: TSimpleNamedValues);
begin
inherited;
If Assigned(Params) then
  begin
    If Params.Exists('TStatReader.FullStats',nvtBool) then
      fFullStats := Params.BoolValue['TStatReader.FullStats'];
    If Params.Exists('TStatReader.KeepStats',nvtBool) then
      If not Params.BoolValue['TStatReader.KeepStats'] then
        ClearStats;
  end
else ClearStats;
end;


{===============================================================================
--------------------------------------------------------------------------------
                                   TStatWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TStatWriter - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TStatWriter - protected methods
-------------------------------------------------------------------------------}

Function TStatWriter.SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TStatWriter.WriteActive(const Buffer; Size: LongInt): LongInt;
var
  BuffPtr:  PByte;
  i:        Integer;
begin
Result := WriteOut(Buffer,Size);
// observe only the amount really written
Inc(fCounter,Result);
If fFullStats then
  begin
    BuffPtr := @Buffer;
    For i := 1 to Result do
      begin
        Inc(fByteCounters[BuffPtr^]);
        Inc(BuffPtr);
      end;
  end;
end;

//------------------------------------------------------------------------------

procedure TStatWriter.Initialize(Params: TSimpleNamedValues);
begin
inherited;
fFullStats := False;
ClearStats;
If Assigned(Params) then
  If Params.Exists('TStatWriter.FullStats',nvtBool) then
    fFullStats := Params.BoolValue['TStatWriter.FullStats'];
end;

//------------------------------------------------------------------------------

procedure TStatWriter.ClearStats;
begin
fCounter := 0;
FillChar(fByteCounters,SizeOf(TStatsPerByte),0);
end;

{-------------------------------------------------------------------------------
    TStatWriter - public methods
-------------------------------------------------------------------------------}

class Function TStatWriter.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [lobPassthrough,lobObserver];
end;

//------------------------------------------------------------------------------

class Function TStatWriter.LayerObjectParams: TLSLayerObjectParams;
begin
SetLength(Result,2);
Result[0] := LayerObjectParam('TStatWriter.FullStats',nvtBool,[loprConstructor,loprInitializer],'Observe all statistics');
Result[1] := LayerObjectParam('TStatWriter.KeepStats',nvtBool,[loprInitializer],'Keep current statistics');
end;

//------------------------------------------------------------------------------

procedure TStatWriter.Init(Params: TSimpleNamedValues);
begin
inherited;
If Assigned(Params) then
  begin
    If Params.Exists('TStatWriter.FullStats',nvtBool) then
      fFullStats := Params.BoolValue['TStatWriter.FullStats'];
    If Params.Exists('TStatWriter.KeepStats',nvtBool) then
      If not Params.BoolValue['TStatWriter.KeepStats'] then
        ClearStats;
  end
else ClearStats;
end;


{===============================================================================
--------------------------------------------------------------------------------
                                  TBufferReader
--------------------------------------------------------------------------------
===============================================================================}
const
  LS_BUFFERREADER_BUFFERSIZE = 1024 * 1024; // 1MiB

{===============================================================================
    TBufferReader - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TBufferReader - protected methods
-------------------------------------------------------------------------------}

Function TBufferReader.SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Flush;
Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TBufferReader.ReadActive(out Buffer; Size: LongInt): LongInt;
begin
{$message 'implement'}
end;

//------------------------------------------------------------------------------

procedure TBufferReader.Initialize(Params: TSimpleNamedValues);
begin
inherited;
fSize := LS_BUFFERREADER_BUFFERSIZE;
If Assigned(Params) then
  If Params.Exists('TBufferReader.Size',nvtInteger) then
    fSize := LongInt(Params.IntegerValue['TBufferReader.Size']);
GetMem(fMemory,fSize);
fUsed := 0;
end;

//------------------------------------------------------------------------------

procedure TBufferReader.Finalize;
begin
FreeMem(fMemory,fSize);
inherited;
end;

{-------------------------------------------------------------------------------
    TBufferReader - public methods
-------------------------------------------------------------------------------}

class Function TBufferReader.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [lobAccumulator];
end;

//------------------------------------------------------------------------------

procedure TBufferReader.Flush;
begin
inherited;
// discard everything still in the buffer and seek back the buffered amount
If fActive and (fUsed > 0) then
  SeekOut(-fUsed,soCurrent);
fUsed := 0;
end;


{===============================================================================
--------------------------------------------------------------------------------
                                  TBufferWriter
--------------------------------------------------------------------------------
===============================================================================}
const
  LS_BUFFERWRITER_BUFFERSIZE = 1024 * 1024; // 1MiB

{===============================================================================
    TBufferWriter - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TBufferWriter - protected methods
-------------------------------------------------------------------------------}

Function TBufferWriter.SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Flush;
Result := SeekOut(Offset,Origin);
end;

//------------------------------------------------------------------------------

Function TBufferWriter.WriteActive(const Buffer; Size: LongInt): LongInt;
var
  Written:  LongInt;
begin
If Size <= (fSize - fUsed) then
  begin
  {
    data will fit free space in the buffer - just store them
  }
    Move(Buffer,Pointer(PtrUInt(fMemory) + PtrUInt(fUsed))^,Size);
    fUsed := fUsed + Size;
    Result := Size;
  end
else If Size < fSize then
  begin
  {
    data won't fit free space, but are smaller than allocated buffer - try write
    out what is currently in the buffer and store new data into buffer
  }
    If fUsed > 0 then
      begin
        // some data are buffered
        Written := WriteOut(fMemory^,fUsed);
        If Written < fUsed then
          begin
            // only part of the buffered data were written, buffer at least part of new data
            Move(Pointer(PtrUInt(fMemory) + PtrUInt(Written))^,fMemory^,fUsed - Written);
            fUsed := fUsed - Written;
            If Size <= (fSize - fUsed) then
              begin
                // whole new data will now fit into free space
                Move(Buffer,Pointer(PtrUInt(fMemory) + PtrUInt(fUsed))^,Size);
                fUsed := fUsed + Size;
                Result := Size;
              end
            else
              begin
                // only part of the new data can fit
                If fAllowPartialWrites then
                  begin
                    // store the part that can fit
                    Result := Min(fSize - fUsed,Size);
                    Move(Buffer,Pointer(PtrUInt(fMemory) + PtrUInt(fUsed))^,Result);
                    fUsed := fUsed + Result;
                  end
                else Result := 0; // partial write is not allowed, don't write anything
              end;
          end
        else
          begin
            // all buffered data were written, buffer new data
            Move(Buffer,fMemory^,Size);
            fUsed := Size;
            Result := Size;
          end;
      end
    else
      begin
        // nothing is buffered (this should never occur here, but whatever...)
        Move(Buffer,fMemory^,Size);
        fUsed := Size;
        Result := Size;
      end;
  end
else
  begin
  {
    data won't fit free space and are larger than allocated buffer - write out
    buffer and pass the new data unchanged or buffer part of them, depending on
    settings
  }
    If fUsed > 0 then
      begin
        Written := WriteOut(fMemory^,fUsed);
        If Written < fUsed then
          begin
            // only part of the buffered data were written
            Move(Pointer(PtrUInt(fMemory) + PtrUInt(Written))^,fMemory^,fUsed - Written);
            fUsed := fUsed - Written;
            If fAllowPartialWrites then
              begin
                // buffer part of new data
                Result := fSize - fUsed;
                Move(Buffer,Pointer(PtrUInt(fMemory) + PtrUInt(fUsed))^,Result);
                fUsed := fSize;
              end
            else Result := 0;
          end
        else
          begin
            // all buffered data were written
            fUsed := 0;
            Result := WriteOut(Buffer,Size);
          end;
      end
    else Result := WriteOut(Buffer,Size);
  end;
// if the buffer is full, try to flush it
If fUsed >= fSize then
  begin
    Written := WriteOut(fMemory^,fSize);
    If Written < fSize then
      begin
        Move(Pointer(PtrUInt(fMemory) + PtrUInt(Written))^,fMemory^,fSize - Written);
        fUsed := fSize - Written;
      end
    else fUsed := 0
  end;
end;

//------------------------------------------------------------------------------

procedure TBufferWriter.Initialize(Params: TSimpleNamedValues);
begin
inherited;
fAllowPartialWrites := False;
fSize := LS_BUFFERWRITER_BUFFERSIZE;
If Assigned(Params) then
  begin
    If Params.Exists('TBufferWriter.Size',nvtInteger) then
      fSize := LongInt(Params.IntegerValue['TBufferWriter.Size']);
    If Params.Exists('TBufferWriter.AllowPartialWrites',nvtBool) then
      fAllowPartialWrites := Params.BoolValue['TBufferWriter.AllowPartialWrites'];
  end;
GetMem(fMemory,fSize);
fUsed := 0;
end;

//------------------------------------------------------------------------------

procedure TBufferWriter.Finalize;
begin
FreeMem(fMemory,fSize);
inherited;
end;

{-------------------------------------------------------------------------------
    TBufferWriter - public methods
-------------------------------------------------------------------------------}

class Function TBufferWriter.LayerObjectKind: TLSLayerObjectKind;
begin
Result := [lobAccumulator];
end;

//------------------------------------------------------------------------------

class Function TBufferWriter.LayerObjectParams: TLSLayerObjectParams;
begin
SetLength(Result,2);
Result[0] := LayerObjectParam('TBufferWriter.Size',nvtInteger,[loprConstructor],'Size of the memory buffer');
Result[1] := LayerObjectParam('TBufferWriter.AllowPartialWrites',nvtInteger,[loprConstructor],'Enables partial data writing');
end;

//------------------------------------------------------------------------------

procedure TBufferWriter.Flush;
begin
inherited;
If fActive and (fUsed > 0) then
  If WriteOut(fMemory^,fUsed) <> fUsed then
    raise EWriteError.Create('TBufferWriter.Flush: Failed to flush all buffered data.');
fUsed := 0;
end;

end.

