unit LayeredStream_Layers;

{$INCLUDE './LayeredStream_defs.inc'}

interface

uses
  SysUtils, Classes,
  AuxClasses, SimpleNamedValues;

{===============================================================================
    Framework-specific exceptions
===============================================================================}
type
{
  ELSException is used as an exception superclass throughout the entire
  LayeredStream framework.
}
  ELSException = class(Exception);

{
  ELSInvalidConnection is raised when a layer does not have any output
  connected. This usually means some serious internal error, since these
  connections are managed automatically and should not be touched anywhere
  else.
}
  ELSInvalidConnection = class(ELSException);

{===============================================================================
--------------------------------------------------------------------------------
                               TLSLayerObjectBase
--------------------------------------------------------------------------------
===============================================================================}
type
{
  TLSLayerObjectType is used to identify what kind of layer object is worked
  on (class method LayerObjectType).
}
  TLSLayerObjectType = (lotUndefined,lotReader,lotWriter);

{
  TLSLayerObjectProperty/TLSLayerObjectProperties types are used by layer
  objects to return information about themselves (via a class method
  LayerObjectProperties) - what they do with data, how they operate or what
  they need for a proper function.

  Note that some of the properties exclude others. For example lopPassthrough
  and lopProcessor is a nonsensical combination, since lopPassthrough explicitly
  states the data are not changed, whereas lopProcessor tells the data are
  changed.
  When such combination is returned by any object, it should be treated as an
  error.

    WARNING - new properties might be added in the future as needed.

  It might not be entirely clear what some properties mean, so here are some
  small examples for clarification:

    lopStopper reader - 128 bytes are to be read, but the object stops the
                        request and simply returns 0 without even attempting to
                        pass the request to the next layer

                        0 is returned, no data are read

    lopStopper writer - 128 bytes are being written, the object stops the
                        requests and returns 0 with no attempt to pass any data
                        to next layer

                        0 is returned, no data are written

    lopConsumer reader - 128 are to be read, the object passes request to read
                         all 128 bytes, but upon return from next layer it
                         consumes 28 bytes and returns only 100 bytes to
                         previous layer

                         only 100 bytes is indicated (passed through the layer),
                         but in reality 128 bytes were read, of which 28 bytes
                         were consumed

    lopConsumer writer - 128 bytes are being written, the object accepts them,
                         consumes 28 bytes, and passes only 100 bytes for write
                         to next layer, but reports that all 128 bytes were
                         written

                         128 bytes is indicated, but in reality only 100 bytes
                         were written (paased through the layer) and 28 bytes
                         were consumed by the layer

    lopGenerator reader - 128 bytes are to be read, but the object passes
                          request to read only 100 bytes to the next layer,
                          upon return it adds (generates) new 28 bytes and adds
                          them to the returned 100 and passes them all to
                          previous layer

                          128 bytes are returned, but only 100 bytes were read
                          and 28 bytes were generated by the layer

    lopGenerator writer - 128 bytes are being written, the object passes only
                          100 bytes to the next layer along with new 28 bytes
                          it generates

                          only 100 bytes is indicated to be written, but in
                          reality 128 bytes were written (100 passed + 28
                          generated)
}
  {$message 'rework - reader should always try to read full request, partial/zero read is allowed only at the end of stream'}
  {$message 'rework - writer should, if possible, write everything requested'}
  TLSLayerObjectProperty = (
    // object properties
    lopNeedsInit,     // layer object requires a call to Init for it to proper function
    lopNeedsFlush,    // layer object requires a call to Flush for it to proper function
    lopNeedsFinal,    // layer object requires a call to Final for it to proper function
    // data passing
    lopAccumulator,   // a copy of at least part of the data is stored in the layer for later use
    lopDelayer,       // streaming of the data can be delayed (typically buffering)
    lopStopper,       // object stops any request for read, write or even a seek
    // data changing and processing
    lopPassthrough,   // data are passing with no change
    lopObserver,      // data are observed - some processing is done above them, but are not changed (eg. hashing, statistics, ...)
    lopProcessor,     // passing data are changed in some way (eg. compression, encryption, ...)
    lopConsumer,      // at least part of the data is consumed by the layer object (possibly all of them)
    lopGenerator,     // some new data are generated by the layer and added to the stream
    // data branching
    lopSplitter,      // at least part of the data is copied into a side channel
    lopJoiner,        // some data are added to the stream from a side channel
    // special
    lopCustom,        // real properties depends on creation parameters
    lopDebug          // anything is possible, no strict rules, refer to source or documentation for details
  );

  TLSLayerObjectProperties = set of TLSLayerObjectProperty;

//------------------------------------------------------------------------------
{
  All layer objects should return information about what parameters they accept
  via a class method LayerObjectParams, following types are used for this
  purpose.

  This info is returned in a form of an array, where each entry contains data
  about one accepted parameter (its name, type and by which method it is
  observed).
}
type
{
  TLSLayerObjectParamReceiver/TLSLayerObjectParamReceivers type is used to
  pass information about which method is observing a specific parameter.
}
  TLSLayerObjectParamReceiver = (loprConstructor,loprInitializer,loprUpdater);

  TLSLayerObjectParamReceivers = set of TLSLayerObjectParamReceiver;

{
  TLSLayerObjectParam type stores information about one accepted parameter.
}
  TLSLayerObjectParam = record
    Name:       String;
    ValueType:  TSNVNamedValueType;
    Receivers:  TLSLayerObjectParamReceivers;
  end;

{
  TLSLayerObjectParams type is used by a method LayerObjectParams to return
  information about all accepted parameters.

    NOTE - the returned array CAN be empty.
}
  TLSLayerObjectParams = array of TLSLayerObjectParam;

{
  LayerObjectParam function is intended to be used internally when constructing
  the array of accepted parameters.
}
Function LayerObjectParam(const Name: String; ValueType: TSNVNamedValueType; Receivers: TLSLayerObjectParamReceivers): TLSLayerObjectParam;

{
  Function LayerObjectParamsJoin should be always used to add new parameters to
  params inherited from descendants.
  Parameters from B are added at the end of A.
}
procedure LayerObjectParamsJoin(var A: TLSLayerObjectParams; const B: TLSLayerObjectParams);

//------------------------------------------------------------------------------
{
  connection events

  they are used internally when connecting individual layers
}
type
  TLSLayerObjectSeekConnection = Function(const Offset: Int64; Origin: TSeekOrigin): Int64 of object;
  TLSLayerObjectReadConnection = Function(out Buffer; Size: LongInt): LongInt of object;
  TLSLayerObjectWriteConnection = Function(const Buffer; Size: LongInt): LongInt of object;

{===============================================================================
    TLSLayerObjectBase - class declaration
===============================================================================}
{
  When implementing new layer object class...

    - do not create direct descendant of TLSLayerObjectBase, always use
      TLSLayerReader or TLSLayerReader
    - do not assume anything about counterpart object
    - do not assume where the layer is located in relation to other layers
    - all layer objects must be created as active
    - always return valid information about all accepted parameters
    - expect methods init, update, flush and final to be called even when not
      needed, expect them to be called at any time, any number of times, in any
      order (when realy needed, wrong order is allowed produce an exception)
    - properly override methods Initialize and Finalize (they are called from
      the constructor and destructor respectively) when needed
    - take care when overriding methods InternalInit and InternalFinal, be aware
      when they are called
    - be aware that seeking might go through the counterpart object and
      circumvent current instance
    - readers must always do everthing they can to read the full requested
      amount of data, partial or zero reads should happen only at the end of
      stream
    - writers must always write all passed data, partial writes should happen
      only when really necessary
}
type
  TLSLayerObjectBase = class(TCustomObject)
  protected
    fCounterpart:     TLSLayerObjectBase; // the other object in layer pair
    fSeekConnection:  TLSLayerObjectSeekConnection;
    fActive:          Boolean;
    procedure SetCounterpart(Value: TLSLayerObjectBase); virtual;
    procedure SetActive(Value: Boolean); virtual;
    Function SeekActive(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual; abstract;
    Function SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    procedure Initialize(Params: TSimpleNamedValues); virtual;
    procedure Finalize; virtual;
  public
    class Function LayerObjectType: TLSLayerObjectType; virtual;              // reader/writer
    class Function LayerObjectProperties: TLSLayerObjectProperties; virtual;  // what the objects does with data, how it behaves, ...
    class Function LayerObjectParams: TLSLayerObjectParams; virtual;          // list of accepted parameters
    constructor Create(Params: TSimpleNamedValues = nil); overload;
    constructor Create(Params: ITransientSimpleNamedValues); overload;
    destructor Destroy; override;
  {
    InternalInit is called by a layered stream just after the object is set up,
    that is after the connections and counterpart are assigned.

    InternalFinal is called by a layered stream before the object is finalized,
    that is before disconnecting it and before the counterpart is set to nil.

    Do not explicitly call these routines, they are only for internal use!
  }
    procedure InternalInit; virtual;
    procedure InternalFinal; virtual;    
  {
    Note that calling Init or Final is not mandatory, they are here only for
    those layer objects that really do need them (indicated by lopNeedsInit and
    lopNeedsFinal flags in LayerObjectProperties). But calling init and final
    on object that does not need it is not considered to be an error and should
    be expected by implementations to happen.
  }
    procedure Init(Params: TSimpleNamedValues = nil); overload; virtual;
    procedure Init(Params: ITransientSimpleNamedValues); overload; virtual;
  {
    Update is to be used only to update parameters during lifetime of the
    object where calling init is not possible or desirable.
    It should not be used as a mean of processing execution.
  }
    procedure Update(Params: TSimpleNamedValues = nil); overload; virtual;
    procedure Update(Params: ITransientSimpleNamedValues); overload; virtual;
    procedure Flush; virtual;
    procedure Final; virtual;
    Function SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64; virtual;
    property Counterpart: TLSLayerObjectBase read fCounterpart write SetCounterpart;
    property Active: Boolean read fActive write SetActive;
    property SeekConnection: TLSLayerObjectSeekConnection read fSeekConnection write fSeekConnection;
  end;

  TLSLayerObjectClass = class of TLSLayerObjectBase;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLSLayerReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerReader - class declaration
===============================================================================}
type
  TLSLayerReader = class(TLSLayerObjectBase)
  protected
    fReadConnection:  TLSLayerObjectReadConnection;
    Function ReadActive(out Buffer; Size: LongInt): LongInt; virtual; abstract;
    Function ReadOut(out Buffer; Size: LongInt): LongInt; virtual;
    procedure Initialize(Params: TSimpleNamedValues); override;
  public
    class Function LayerObjectType: TLSLayerObjectType; override;
    Function ReadIn(out Buffer; Size: LongInt): LongInt; virtual;
    property ReadConnection: TLSLayerObjectReadConnection read fReadConnection write fReadConnection;
  end;

  TLSLayerReaderClass = class of TLSLayerReader;

{===============================================================================
--------------------------------------------------------------------------------
                                 TLSLayerWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerWriter - class declaration
===============================================================================}
type
  TLSLayerWriter = class(TLSLayerObjectBase)
  protected
    fWriteConnection: TLSLayerObjectWriteConnection;
    Function WriteActive(const Buffer; Size: LongInt): LongInt; virtual; abstract;
    Function WriteOut(const Buffer; Size: LongInt): LongInt; virtual;
    procedure Initialize(Params: TSimpleNamedValues); override;
  public
    class Function LayerObjectType: TLSLayerObjectType; override;
    Function WriteIn(const Buffer; Size: LongInt): LongInt; virtual;
    property WriteConnection: TLSLayerObjectWriteConnection read fWriteConnection write fWriteConnection;
  end;

  TLSLayerWriterClass = class of TLSLayerWriter;

implementation

{$IFDEF FPC_DisableWarns}
  {$DEFINE FPCDWM}
  {$DEFINE W5024:={$WARN 5024 OFF}} // Parameter "$1" not used
{$ENDIF}

{===============================================================================
--------------------------------------------------------------------------------
                               TLSLayerObjectBase
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerObjectBase - Auxiliary functions
===============================================================================}

Function LayerObjectParam(const Name: String; ValueType: TSNVNamedValueType; Receivers: TLSLayerObjectParamReceivers): TLSLayerObjectParam;
begin
Result.Name := Name;
Result.ValueType := ValueType;
Result.Receivers := Receivers;
end;

//------------------------------------------------------------------------------

procedure LayerObjectParamsJoin(var A: TLSLayerObjectParams; const B: TLSLayerObjectParams);
var
  AOldLen:  Integer;
  i:        Integer;
begin
If Length(B) > 0 then
  begin
    AOldLen := Length(A);
    SetLength(A,AOldLen + Length(B));
    For i := Low(B) to High(B) do
      A[AOldLen + i] := B[i];
  end;
end;

{===============================================================================
    TLSLayerObjectBase - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerObjectBase - protected methods
-------------------------------------------------------------------------------}

procedure TLSLayerObjectBase.SetCounterpart(Value: TLSLayerObjectBase);
begin
fCounterpart := Value;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.SetActive(Value: Boolean);
begin
If Value <> fActive then
  begin
    If not Value then // deactivating, do flush
      Flush;
    fActive := Value;
  end;
end;

//------------------------------------------------------------------------------

Function TLSLayerObjectBase.SeekOut(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
Result := 0;
If Assigned(fSeekConnection) then
  Result := fSeekConnection(Offset,Origin)
else
  ELSInvalidConnection.Create('TLSLayerObjectBase.SeekOut: Seek connection not assigned.');
end;

//------------------------------------------------------------------------------

{$IFDEF FPCDWM}{$PUSH}W5024{$ENDIF}
procedure TLSLayerObjectBase.Initialize(Params: TSimpleNamedValues);
begin
fCounterpart := nil;
fSeekConnection := nil;
fActive := True;
end;
{$IFDEF FPCDWM}{$POP}{$ENDIF}

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Finalize;
begin
// no action
end;

{-------------------------------------------------------------------------------
    TLSLayerObjectBase - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerObjectBase.LayerObjectType: TLSLayerObjectType;
begin
Result := lotUndefined;
end;

//------------------------------------------------------------------------------

class Function TLSLayerObjectBase.LayerObjectProperties: TLSLayerObjectProperties;
begin
Result := [];
end;

//------------------------------------------------------------------------------

class Function TLSLayerObjectBase.LayerObjectParams: TLSLayerObjectParams;
begin
SetLength(Result,0);
end;

//------------------------------------------------------------------------------

constructor TLSLayerObjectBase.Create(Params: TSimpleNamedValues = nil);
begin
inherited Create;
Initialize(Params);
end;

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

constructor TLSLayerObjectBase.Create(Params: ITransientSimpleNamedValues);
begin
Create(Params.Implementor);
end;

//------------------------------------------------------------------------------

destructor TLSLayerObjectBase.Destroy;
begin
Finalize;
inherited;
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.InternalInit;
begin
// no action
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.InternalFinal;
begin
// no action
end;

//------------------------------------------------------------------------------

{$IFDEF FPCDWM}{$PUSH}W5024{$ENDIF}
procedure TLSLayerObjectBase.Init(Params: TSimpleNamedValues = nil);
begin
// nothing to do
end;
{$IFDEF FPCDWM}{$POP}{$ENDIF}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

procedure TLSLayerObjectBase.Init(Params: ITransientSimpleNamedValues);
begin
Init(Params.Implementor);
end;

//------------------------------------------------------------------------------

{$IFDEF FPCDWM}{$PUSH}W5024{$ENDIF}
procedure TLSLayerObjectBase.Update(Params: TSimpleNamedValues = nil);
begin
// nothing to do
end;
{$IFDEF FPCDWM}{$POP}{$ENDIF}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

procedure TLSLayerObjectBase.Update(Params: ITransientSimpleNamedValues);
begin
Update(Params.Implementor);
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Flush;
begin
// nothing to do
end;

//------------------------------------------------------------------------------

procedure TLSLayerObjectBase.Final;
begin
// nothing to do
end;

//------------------------------------------------------------------------------

Function TLSLayerObjectBase.SeekIn(const Offset: Int64; Origin: TSeekOrigin): Int64;
begin
If fActive then
  Result := SeekActive(Offset,Origin)
else
  Result := SeekOut(Offset,Origin);
end;


{===============================================================================
--------------------------------------------------------------------------------
                              TLSLayerReader
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerReader - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerReader - protected methods
-------------------------------------------------------------------------------}

Function TLSLayerReader.ReadOut(out Buffer; Size: LongInt): LongInt;
begin
Result := 0;
If Assigned(fReadConnection) then
  Result := fReadConnection(Buffer,Size)
else
  ELSInvalidConnection.Create('TLSLayerReader.ReadOut: Read connection not assigned.');
end;

//------------------------------------------------------------------------------

procedure TLSLayerReader.Initialize(Params: TSimpleNamedValues);
begin
inherited;
fReadConnection := nil;
end;

{-------------------------------------------------------------------------------
    TLSLayerReader - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerReader.LayerObjectType: TLSLayerObjectType;
begin
Result := lotReader;
end;

//------------------------------------------------------------------------------

Function TLSLayerReader.ReadIn(out Buffer; Size: LongInt): LongInt;
begin
If fActive then
  Result := ReadActive(Buffer,Size)
else
  Result := ReadOut(Buffer,Size);
end;


{===============================================================================
--------------------------------------------------------------------------------
                              TLSLayerWriter
--------------------------------------------------------------------------------
===============================================================================}
{===============================================================================
    TLSLayerWriter - class implementation
===============================================================================}
{-------------------------------------------------------------------------------
    TLSLayerWriter - protected methods
-------------------------------------------------------------------------------}

Function TLSLayerWriter.WriteOut(const Buffer; Size: LongInt): LongInt;
begin
Result := 0;
If Assigned(fWriteConnection) then
  Result := fWriteConnection(Buffer,Size)
else
  ELSInvalidConnection.Create('TLSLayerWriter.WriteOut: Write connection not assigned.');
end;

//------------------------------------------------------------------------------

procedure TLSLayerWriter.Initialize(Params: TSimpleNamedValues);
begin
inherited;
fWriteConnection := nil;
end;

{-------------------------------------------------------------------------------
    TLSLayerWriter - public methods
-------------------------------------------------------------------------------}

class Function TLSLayerWriter.LayerObjectType: TLSLayerObjectType;
begin
Result := lotWriter;
end;

//------------------------------------------------------------------------------

Function TLSLayerWriter.WriteIn(const Buffer; Size: LongInt): LongInt;
begin
If fActive then
  Result := WriteActive(Buffer,Size)
else
  Result := WriteOut(Buffer,Size);
end;


end.
